#include <grpcpp/ext/proto_server_reflection_plugin.h>
#include <grpcpp/grpcpp.h>
#include <grpcpp/health_check_service_interface.h>

#include "dh.h"
#include "protos/crypto.grpc.pb.h"
#include "util.h"

class CryptoServiceImpl final : public crypto::Crypto::Service {
 public:
  ::grpc::Status OpenConnection(
      ::grpc::ServerContext *context,
      const ::crypto::OpenConnectionRequest *request,
      ::crypto::OpenConnectionResponse *response) override {
    for (int i = 0; i < request->handshakedatalist_size(); i++) {
      crypto::HandshakeData client_handshake_data =
          request->handshakedatalist(i);
      crypto::CipherSuite client_cipher_suite =
          client_handshake_data.ciphersuite();
      const std::string client_data_str = client_handshake_data.data();
      const unsigned char *client_data =
          reinterpret_cast<const unsigned char *>(client_data_str.c_str());

      if (is_supported(client_cipher_suite)) {
        crypto::HandshakeData *handshakeData =
            response->mutable_handshakedata();
        get_server_handshake_data(client_cipher_suite, client_data,
                                  client_data_str.length(), handshakeData);

        break;
      }
    }
    return grpc::Status::OK;
  }

 private:
  bool is_supported(crypto::CipherSuite cipherSuite) {
    // TODO
    return true;
  }

  void get_server_handshake_data(crypto::CipherSuite client_cipher_suite,
                                 const unsigned char *client_data,
                                 size_t client_data_len,
                                 crypto::HandshakeData *handshakeData) {
    size_t server_handshake_data_len = 0;
    unsigned char *server_handshake_data = NULL;  // TODO: free or not?

    switch (client_cipher_suite) {
      case crypto::CipherSuite::DH:
      case crypto::CipherSuite::ECDH:
        dh(client_data, client_data_len, &server_handshake_data,
           &server_handshake_data_len);
        break;
    }
    if (server_handshake_data != NULL) {
      handshakeData->set_ciphersuite(client_cipher_suite);
      handshakeData->set_data(server_handshake_data, server_handshake_data_len);
    }

    free(server_handshake_data);
  }

  void dh(const unsigned char *client_raw_pub_key, size_t peer_raw_pub_key_len,
          unsigned char **pub_key, size_t *pub_key_len) {
    EVP_PKEY *key_pair = NULL;
    EVP_PKEY *peer_pub_key = NULL;
    //
    size_t shared_secret_len = 0;
    unsigned char *shared_secret = NULL;

    // -----

    dh_parse_public_key(&peer_pub_key, client_raw_pub_key,
                        peer_raw_pub_key_len);
    if (peer_pub_key == NULL) {
      goto cleanup;
    }
    // Generate server's public key using infomation from Alice's public key
    dh_generate_key_pair_from_peer_public_key(&key_pair, peer_pub_key);
    if (peer_pub_key == NULL) {
      goto cleanup;
    }
    // Extract server's raw public key
    extract_public_key(key_pair, pub_key, pub_key_len);
    if (*pub_key == NULL) {
      goto cleanup;
    }
    printf("Server's public key: ");
    print_hex(*pub_key, *pub_key_len);
    // Server generates shared secret
    dh_generate_shared_secret(key_pair, peer_pub_key, &shared_secret,
                              &shared_secret_len);
    if (shared_secret == NULL) {
      goto cleanup;
    }
    printf("Shared secret generated by server: ");
    print_hex_with_delim(shared_secret, shared_secret_len, ":");

  cleanup:
    OPENSSL_free(shared_secret);
    //
    EVP_PKEY_free(peer_pub_key);
    EVP_PKEY_free(key_pair);
  }
};

int main(int argc, char **argv) {
  std::string server_address = "0.0.0.0:50051";
  CryptoServiceImpl service;

  grpc::EnableDefaultHealthCheckService(true);
  grpc::reflection::InitProtoReflectionServerBuilderPlugin();
  grpc::ServerBuilder builder;
  // Listen on the given address without any authentication mechanism.
  builder.AddListeningPort(server_address, grpc::InsecureServerCredentials());
  // Register "service" as the instance through which we'll communicate with
  // clients. In this case it corresponds to an *synchronous* service.
  builder.RegisterService(&service);
  // Finally assemble the server.
  std::unique_ptr<grpc::Server> server(builder.BuildAndStart());
  std::cout << "Server listening on " << server_address << std::endl;

  // Wait for the server to shutdown. Note that some other thread must be
  // responsible for shutting down the server for this call to ever return.
  server->Wait();

  return 0;
}