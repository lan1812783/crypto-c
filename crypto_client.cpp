#include <grpcpp/create_channel.h>
#include <openssl/evp.h>

#include <memory>

#include "dh.h"
#include "protos/crypto.grpc.pb.h"
#include "protos/crypto.pb.h"
#include "util.h"

class Client {
 public:
  Client(std::shared_ptr<grpc::Channel> channel)
      : stub_(crypto::Crypto::NewStub(channel)) {}

  void do_handshake(crypto::CipherSuite cipherSuite) {
    EVP_PKEY *client_key_pair = NULL;
    //
    size_t client_pub_key_len = 0;
    unsigned char *client_pub_key = NULL;
    //
    EVP_PKEY *server_pub_key = NULL;
    //
    size_t shared_secret_len = 0;
    unsigned char *shared_secret = NULL;

    // -----

    switch (cipherSuite) {
      case crypto::CipherSuite::DH:
        dh_generate_key_pair(&client_key_pair, DH_KEY_SIZE_2048_256);
        break;
      case crypto::CipherSuite::ECDH:
        ecdh_generate_key_pair(&client_key_pair, NID_X9_62_prime256v1);
        break;
      default:
        printf("Invalid handshake algorithm");
    }
    if (client_key_pair == NULL) {
      goto cleanup;
    }
    // Extract client's raw public key
    extract_public_key(client_key_pair, &client_pub_key, &client_pub_key_len);
    if (client_pub_key == NULL) {
      goto cleanup;
    }
    printf("Client's public key: ");
    print_hex(client_pub_key, client_pub_key_len);

    // RPC call
    send_handshake_data(cipherSuite, client_pub_key, client_pub_key_len,
        &server_pub_key);
    if (server_pub_key == NULL) {
      goto cleanup;
    }
    // Client generates the shared secret
    dh_generate_shared_secret(client_key_pair, server_pub_key, &shared_secret,
                              &shared_secret_len);
    if (shared_secret == NULL) {
      goto cleanup;
    }
    printf("Shared secret generated by client: ");
    print_hex_with_delim(shared_secret, shared_secret_len, ":");

  cleanup:
    OPENSSL_free(shared_secret);
    EVP_PKEY_free(server_pub_key);
    //
    SAFE_DEL(client_pub_key);
    EVP_PKEY_free(client_key_pair);
  }

  void send_handshake_data(crypto::CipherSuite cipherSuite,
                           unsigned char *client_pub_key,
                           size_t client_pub_key_len,
                           EVP_PKEY **server_pub_key) {
    grpc::ClientContext context;
    crypto::OpenConnectionRequest request;
    crypto::HandshakeData *dh_handshake_data = request.add_handshakedatalist();
    dh_handshake_data->set_ciphersuite(cipherSuite);
    dh_handshake_data->set_data(client_pub_key, client_pub_key_len);
    crypto::OpenConnectionResponse response;
    grpc::Status status = stub_->OpenConnection(&context, request, &response);

    if (!status.ok()) {
      std::cout << "Error " << status.error_code() << ": "
                << status.error_message() << '\n';
      return;
    }

    crypto::HandshakeData server_handshake_data = response.handshakedata();
    get_server_pub_key(&server_handshake_data, server_pub_key);
  }

  void get_server_pub_key(crypto::HandshakeData *server_handshake_data,
                          EVP_PKEY **server_pub_key) {
    // TODO: verify server_handshake_data.ciphersuite()

    const std::string server_data_str = server_handshake_data->data();
    size_t server_data_len = server_data_str.length();
    const unsigned char *server_data =
        reinterpret_cast<const unsigned char *>(server_data_str.c_str());
    dh_parse_public_key(server_pub_key, server_data, server_data_len);
  }

 private:
  std::unique_ptr<crypto::Crypto::Stub> stub_;
};

int main(int argc, char **argv) {
  Client client(grpc::CreateChannel("localhost:50051",
                                    grpc::InsecureChannelCredentials()));
  client.do_handshake(crypto::CipherSuite::DH);
  client.do_handshake(crypto::CipherSuite::ECDH);
}
