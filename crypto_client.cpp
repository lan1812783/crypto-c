#include <grpcpp/create_channel.h>
#include <openssl/evp.h>

#include <memory>

#include "dh.h"
#include "protos/crypto.grpc.pb.h"
#include "util.h"

class Client {
 public:
  Client(std::shared_ptr<grpc::Channel> channel)
      : stub_(crypto::Crypto::NewStub(channel)) {}

  void do_handshake() {
    EVP_PKEY *key_pair = NULL;
    //
    size_t pub_key_len = 0;
    unsigned char *pub_key = NULL;
    //
    EVP_PKEY *server_pub_key = NULL;
    //
    size_t shared_secret_len = 0;
    unsigned char *shared_secret = NULL;

    // -----

    // ecdh_generate_key_pair(&key_pair, NID_X9_62_prime256v1);
    dh_generate_key_pair(&key_pair, DH_KEY_SIZE_2048_256);
    if (key_pair == NULL) {
      goto cleanup;
    }
    // Extract client's raw public key
    extract_public_key(key_pair, &pub_key, &pub_key_len);
    if (pub_key == NULL) {
      goto cleanup;
    }
    printf("Client's public key: ");
    print_hex(pub_key, pub_key_len);

    // RPC call
    send_handshake_data(pub_key, pub_key_len, &server_pub_key);
    if (server_pub_key == NULL) {
      goto cleanup;
    }
    // Client generates the shared secret
    dh_generate_shared_secret(key_pair, server_pub_key, &shared_secret,
                              &shared_secret_len);
    if (shared_secret == NULL) {
      goto cleanup;
    }
    printf("Shared secret generated by client: ");
    print_hex_with_delim(shared_secret, shared_secret_len, ":");

  cleanup:
    OPENSSL_free(shared_secret);
    EVP_PKEY_free(server_pub_key);
    //
    SAFE_DEL(pub_key);
    EVP_PKEY_free(key_pair);
  }

  void send_handshake_data(unsigned char *pub_key, size_t pub_key_len,
                           EVP_PKEY **server_pub_key) {
    grpc::ClientContext context;
    crypto::OpenConnectionRequest request;
    crypto::HandshakeData *dh_handshake_data = request.add_handshakedatalist();
    dh_handshake_data->set_ciphersuite(crypto::CipherSuite::DH);
    dh_handshake_data->set_data(pub_key, pub_key_len);
    crypto::OpenConnectionResponse response;
    grpc::Status status = stub_->OpenConnection(&context, request, &response);

    if (!status.ok()) {
      std::cout << "Error " << status.error_code() << ": "
                << status.error_message() << '\n';
      return;
    }

    crypto::HandshakeData server_handshake_data = response.handshakedata();
    std::cout << server_handshake_data.ciphersuite() << '\n';

    const std::string server_data_str = server_handshake_data.data();
    const unsigned char *server_data =
        reinterpret_cast<const unsigned char *>(server_data_str.c_str());

    dh_parse_public_key(server_pub_key, server_data, server_data_str.length());
  }

 private:
  std::unique_ptr<crypto::Crypto::Stub> stub_;
};

int main(int argc, char **argv) {
  Client client(grpc::CreateChannel("localhost:50051",
                                    grpc::InsecureChannelCredentials()));
  client.do_handshake();
}
